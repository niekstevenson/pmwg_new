i=i+1
if (u < acc) {
curValues<-proposal
}
chains[j,]<- curValues
#################################################
# Begin
# update covariance matrix with adaptive MCMC
#################################################
if (i > 100) {
if (i==101) {
sigMat=cov(chains)
thetaM=apply(chains, 2, mean)
} else
{
tmp=update.cov(sigMat, i, thetaM, curValues, nPars)
sigMat=tmp$sigMat
thetaM=tmp$thetaM
}
}
###############################################
# Begin
# update epsilon using RM
###############################################
if (j>n0) {
epsilon<-update.epsilon(epsilon^2, acc, pstar, j, nPars, alpha)
i=i+1
epsilon.vec<-c(epsilon.vec, epsilon)
if ((j <= (iMax+n0)) && (Numbig<5 || Numsmall<5)) {
Toobig<- (epsilon > (3*epsilonStart))
Toosmall<-(epsilon < (epsilonStart/3))
if (Toobig || Toosmall) {
#restart the algorithm
cat("restart the program at", i, "th iteration", "\n")
epsilon.restart<-c(epsilon.restart, epsilon)
Numbig<- Numbig + Toobig
Numsmall <- Numsmall + Toosmall
j<-n0
epsilonStart <-epsilon
}
} #end iMax
}
}
return(list(chains = chains, epsilons = epsilon.vec, epsilonRestarts = epsilon.restart, accept = acc.vec))
} #end niter
library(rtdists)
b <- 1
t0 <- .15
mean_v <- c(2, 3)
sd_v <- .5
dat <- rLBA(500, A = 0, b = 1, t0 = .15, mean_v = c(2,3), sd_v = .5)
test <- mcmcTest(niter = 10000, startValues = rep(0, 2), epsilonStart = .5, data = dat)
accept<-test$accept[-1]
#calculate running mean acceptance rate
meanacc<-rep(NA, length(accept))
for (i in c(1:length(accept))) {
meanacc[i]=     mean(accept[round(i/2) :i])
}
burnin <- 500
#begin plot
############
par(mfrow=c(2,2))
plot(test$chains[,1], type="l", main = "trace plot of MCMC for parameter 1")
hist(test$chains[-c(1:burnin),1], probability=T)
abline(v = 1, lty = 2, col = "red", lwd = 3)
plot(test$epsilons, type="l", col=3, ylim=c(0, max(test$epsilons)), ylab="epsilon")
plot(meanacc, type="l", col=2, ylim=c(0,1), ylab="acceptance probability")
abline(h=0.234)
rm(list = ls())
library(rtdists)
setwd("~/pmwg_new")
source("pmwg/sampling.R")
log_likelihood=function(x,data,sample=TRUE) {
x=exp(x)
bs=x["A"]+x[c("b1","b2","b3")][data$condition]
if (sample) { #for sampling
out=rLBA(n=nrow(data),A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
} else { #for calculating density
out=dLBA(rt=data$rt,response=data$resp,A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
bad=(out<1e-10)|(!is.finite(out))
out[bad]=1e-10
out=sum(log(out))
}
out
}
n.trials = 75      #number trials per subject per conditions
n.subj = 5        #number of subjects
n.cond = 3          #number of conditions
names=c("subject","rt","resp","condition") #names of columns
data = data.frame(matrix(NA, ncol = length(names), nrow = (n.trials*n.subj*n.cond))) #empty data frame
names(data)=names
data$condition = rep(1:n.cond,times = n.trials) #filling in condition
data$subject = rep(1:n.subj, each = n.trials*n.cond) #filling in subjects
parameter.names=c("b1","b2","b3", "A","v1","v2","t0")
n.parameters=length(parameter.names)
ptm <- array(dim = n.parameters, dimnames = list(parameter.names)) #an empty array where i will put parameter values
ptm[1:n.parameters]=c(0.1,0.3,0.5,0.4,1.2,0.3,-2.4)
exp(ptm)
vars = abs(ptm)/10 #off diagonal correlations are done as absolute/10
sigmaC <- matrix(c(.8, .5, .4, .15, .15, .3, -.15,
.5, .8, .4, .2, .3, .3, .3,
.4, .4, .8, .1, .1, .2, .2,
.15, .2, .1, .8, .2, .2, .1,
.15, .3, .1, .2, .8, .5, .2,
.3, .3, .2, .2, .5, .8, .1,
-.15, .3, .2, .1, .2, .1, .8),
nrow=7,ncol=7)
###std dev correlation on diagonal - you might think this should be corr = 1, but it's actually the standard deviation
diag(sigmaC)=sqrt(vars)
sigmaC <- sdcor2cov(sigmaC)
subj_random_effects <- t(mvtnorm::rmvnorm(n.subj,mean=ptm,sigma=sigmaC))
for (i in 1:n.subj){
tmp<- log_likelihood(subj_random_effects[,i],sample=TRUE,data=data[data$subject==i,])
data$rt[data$subject==i]=tmp$rt
data$resp[data$subject==i]=tmp$response
}
pars <- rownames(subj_random_effects)
priors <- list(
theta_mu_mean = rep(0, length(pars)),
theta_mu_var = diag(rep(1, length(pars)))
)
# Create the Particle Metropolis within Gibbs sampler object ------------------
lba_loglike <- function(x, data, sample = FALSE) {
x <- exp(x)
if (any(data$rt < x["t0"])) {
return(-1e10)
}
if (sample){
data$rt=NA
data$resp = NA
}
bs <- x["A"] + x[c("b1", "b2", "b3")][data$condition]
if (sample) {
out <- rtdists::rLBA(n = nrow(data),
A = x["A"],
b = bs,
t0 = x["t0"],
mean_v = x[c("v1", "v2")],
sd_v = c(1, 1),
distribution = "norm",
silent = TRUE)
data$rt <- out$rt
data$resp <- out$resp
} else {
out <- rtdists::dLBA(rt = data$rt,
response = data$resp,
A = x["A"],
b = bs,
t0 = x["t0"],
mean_v = list(x["v1"],x[ "v2"]),
sd_v = c(1, 1),
distribution = "norm",
silent = TRUE)
bad <- (out < 1e-10) | (!is.finite(out))
out[bad] <- 1e-10
out <- sum(log(out))
}
if (sample){return(data)}
if (!sample){return(out)}
}
sampler <- pmwgs(
data = data,
pars = pars,
prior = priors,
ll_func = lba_loglike
)
sampler <- init(sampler, n_cores = 5) # i don't use any start points here
# Sample! -------------------------------------------------------------------
burned3 <- run_stage(sampler, stage = "burn",iter = 1000, particles = 100, n_cores = 16, pstar = .7)
adapted <- run_stage(burned, stage = "adapt", iter = 5000, particles = 100, n_cores = 16, pstar =.6)
sampled <- run_stage(adapted, stage = "sample", iter = 2500, particles = 100, n_cores = 16, pstar = .6)
rm(list = ls())
library(rtdists)
setwd("Documents/UVA/2021/pmwg_new")
source("pmwg/sampling.R")
log_likelihood=function(x,data,sample=TRUE) {
x=exp(x)
bs=x["A"]+x[c("b1","b2","b3")][data$condition]
if (sample) { #for sampling
out=rLBA(n=nrow(data),A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
} else { #for calculating density
out=dLBA(rt=data$rt,response=data$resp,A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
bad=(out<1e-10)|(!is.finite(out))
out[bad]=1e-10
out=sum(log(out))
}
out
}
n.trials = 75      #number trials per subject per conditions
n.subj = 5        #number of subjects
n.cond = 3          #number of conditions
names=c("subject","rt","resp","condition") #names of columns
data = data.frame(matrix(NA, ncol = length(names), nrow = (n.trials*n.subj*n.cond))) #empty data frame
names(data)=names
data$condition = rep(1:n.cond,times = n.trials) #filling in condition
data$subject = rep(1:n.subj, each = n.trials*n.cond) #filling in subjects
parameter.names=c("b1","b2","b3", "A","v1","v2","t0")
n.parameters=length(parameter.names)
ptm <- array(dim = n.parameters, dimnames = list(parameter.names)) #an empty array where i will put parameter values
ptm[1:n.parameters]=c(0.1,0.3,0.5,0.4,1.2,0.3,-2.4)
exp(ptm)
vars = abs(ptm)/10 #off diagonal correlations are done as absolute/10
sigmaC <- matrix(c(.8, .5, .4, .15, .15, .3, -.15,
.5, .8, .4, .2, .3, .3, .3,
.4, .4, .8, .1, .1, .2, .2,
.15, .2, .1, .8, .2, .2, .1,
.15, .3, .1, .2, .8, .5, .2,
.3, .3, .2, .2, .5, .8, .1,
-.15, .3, .2, .1, .2, .1, .8),
nrow=7,ncol=7)
###std dev correlation on diagonal - you might think this should be corr = 1, but it's actually the standard deviation
diag(sigmaC)=sqrt(vars)
sigmaC <- sdcor2cov(sigmaC)
subj_random_effects <- t(mvtnorm::rmvnorm(n.subj,mean=ptm,sigma=sigmaC))
for (i in 1:n.subj){
tmp<- log_likelihood(subj_random_effects[,i],sample=TRUE,data=data[data$subject==i,])
data$rt[data$subject==i]=tmp$rt
data$resp[data$subject==i]=tmp$response
}
pars <- rownames(subj_random_effects)
priors <- list(
theta_mu_mean = rep(0, length(pars)),
theta_mu_var = diag(rep(1, length(pars)))
)
# Create the Particle Metropolis within Gibbs sampler object ------------------
lba_loglike <- function(x, data, sample = FALSE) {
x <- exp(x)
if (any(data$rt < x["t0"])) {
return(-1e10)
}
if (sample){
data$rt=NA
data$resp = NA
}
bs <- x["A"] + x[c("b1", "b2", "b3")][data$condition]
if (sample) {
out <- rtdists::rLBA(n = nrow(data),
A = x["A"],
b = bs,
t0 = x["t0"],
mean_v = x[c("v1", "v2")],
sd_v = c(1, 1),
distribution = "norm",
silent = TRUE)
data$rt <- out$rt
data$resp <- out$resp
} else {
out <- rtdists::dLBA(rt = data$rt,
response = data$resp,
A = x["A"],
b = bs,
t0 = x["t0"],
mean_v = list(x["v1"],x[ "v2"]),
sd_v = c(1, 1),
distribution = "norm",
silent = TRUE)
bad <- (out < 1e-10) | (!is.finite(out))
out[bad] <- 1e-10
out <- sum(log(out))
}
if (sample){return(data)}
if (!sample){return(out)}
}
sampler <- pmwgs(
data = data,
pars = pars,
prior = priors,
ll_func = lba_loglike
)
sampler <- init(sampler, n_cores = 5) # i don't use any start points here
# Sample! -------------------------------------------------------------------
burned3 <- run_stage(sampler, stage = "burn",iter = 1000, particles = 100, n_cores = 16, pstar = .7)
adapted <- run_stage(burned, stage = "adapt", iter = 5000, particles = 100, n_cores = 16, pstar =.6)
sampled <- run_stage(adapted, stage = "sample", iter = 2500, particles = 100, n_cores = 16, pstar = .6)
rm(list = ls())
setwd("~/Documents/UVA/2021/pmwg_new/")
source("pmwg/sampling.R")
joint_ll <- function(x, data){
parPreFixs <- gsub("[|].*", "", names(x))
totalSum <- 0
for(mod in unique(parPreFixs)){
currentPars <- x[which(parPreFixs == mod)]
names(currentPars) <- gsub(".*[|]", "", names(currentPars))
modelData <- data[[mod]][[1]]
totalSum <- totalSum + log_likelihood(currentPars, modelData, sample = F)
}
return(totalSum)
}
fitSims <- function(df, pars, var, n.subj){
priors <- list(
theta_mu_mean = rep(0, length(pars)),
theta_mu_var = diag(rep(var, length(pars)))
)
# Create the Particle Metropolis within Gibbs sampler object ------------------
sampler <- pmwgs(
data = df,
pars = pars,
prior = priors,
ll_func = joint_ll
)
# start the sampler ---------------------------------------------------------
sampler <- init(sampler, n_cores = 48) # i don't use any start points here
# Sample! -------------------------------------------------------------------
save(sampler, file = paste0("./samples/sim/LBA", n.subj, ".RData"))
burned <- run_stage(sampler, stage = "burn",iter = 2000, particles = 100, n_cores =48, pstar = .6)
save(burned, file = paste0("./samples/sim/LBA", n.subj, ".RData"))
epsilon <- burned$epsilon[length(burned$epsilon)]
adapted <- run_stage(burned, stage = "adapt", iter = 5000, particles = 100, n_cores = 48, pstar = .6)
epsilon <- adapted$epsilon[length(adapted$epsilon)]
sampled <- run_stage(adapted, stage = "sample", iter = 1000, particles = 100, n_cores = 48, pstar = .6)
save(sampled, file = paste0("./samples/sim/LBA4T_3_", n.subj, ".RData"))
}
log_likelihood=function(x,data, sample=TRUE) {
x <- exp(x)
bPars <- grep("b", names(x))
bs <- x["A"]+x[bPars][data$condition]
if (sample) { #for sampling
out=rLBA(n=nrow(data),A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
} else { #for calculating density
out=dLBA(rt=data$rt,response=data$resp,A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
bad=(out<1e-10)|(!is.finite(out))
out[bad]=1e-10
out=sum(log(out))
}
out
}
n.trials <- 100      #number trials per subject per conditions
n.subj <- 15 #number of subjects
n.cond <- 3
n.exp <- 4
allparameters <- numeric()
alldata <- list()
for(i in 1:n.exp){
names=c("subject","rt","resp","condition") #names of columns
data <- data.frame(matrix(NA, ncol = length(names), nrow = (n.trials*n.subj*n.cond))) #empty data frame
names(data) <- names
data$condition <- rep(1:n.cond,times = n.trials) #filling in condition
data$subject <- rep(1:n.subj, each = n.trials*n.cond) #filling in subjects
alldata[[i]] <- data
parameter.names <- c(c("A","v1","v2","t0"), c(paste0("b", 1:3)))
parameters <- c((0.1 + .02*i)*(-1)^i + c(0.4, 1.2, .7, -2.4), seq(0.1, 0.5, length.out = 3))
names(parameters) <- paste0("Mod", i, "|", parameter.names)
allparameters <- c(allparameters, parameters)
}
fillCorMatrix <- function(matrix, name1, name2, value){
matrix[grep(name1, rownames(matrix)), grep(name2, colnames(matrix))] <- value
matrix[grep(name2, rownames(matrix)), grep(name1, colnames(matrix))] <- value
return(matrix)
}
adjustCorMatrix <- function(matrix, adj){
#Was probably a cleverer way to do this
rowNames <- rownames(matrix)
for(i in 1:nrow(matrix)){
rowPreFix <- substr(rowNames[i], 0, 4)
matrix[i,!grepl(rowPreFix, colnames(matrix))] <- .3*matrix[i,!grepl(rowPreFix, colnames(matrix))]
}
return(matrix)
}
exp(allparameters)
n.parameters=length(allparameters)
corMat <- matrix(0, nrow = n.parameters, ncol = n.parameters)
rownames(corMat) <- colnames(corMat) <- names(allparameters)
corMat[grep("A", rownames(corMat)),] <- .3
corMat[,grep("A", colnames(corMat))] <- .3
corMat <- fillCorMatrix(corMat, "v", "b", .25)
corMat <- fillCorMatrix(corMat, "v", "v", .4)
corMat <- fillCorMatrix(corMat, "b", "b", .4)
corMat <- fillCorMatrix(corMat, "t0", "v", -.1)
corMat <- fillCorMatrix(corMat, "t0", "b", -.25)
corMat <- adjustCorMatrix(corMat, .33)
vars = abs(allparameters)/15 #off diagonal correlations are done as absolute/10
###std dev correlation on diagonal - you might think this should be corr = 1, but it's actually the standard deviation
diag(corMat)=sqrt(vars)
corMat <- sdcor2cov(corMat)
subj_random_effects <- t(mvtnorm::rmvnorm(n.subj,mean=allparameters,sigma=corMat))
exp(subj_random_effects)
parPreFixs <- gsub("[|].*", "", rownames(subj_random_effects))
df <- data.frame(subject = 1:n.subj)
for(i in 1:n.exp){
modIdx <- which(parPreFixs == paste0("Mod", i))
task_random_effects <- subj_random_effects[modIdx,]
rownames(task_random_effects) <- gsub(".*[|]", "", rownames(task_random_effects))
data <- alldata[[i]]
for (j in 1:n.subj){
tmp<- log_likelihood(task_random_effects[,j],sample=TRUE,data=data[data$subject==j,])
data$rt[data$subject==j]=tmp$rt
data$resp[data$subject==j]=tmp$response
}
df[paste0("Mod", i)] <- I(list(split(data, f = data$subject)))
}
pars <- rownames(subj_random_effects)
debug(fitSims)
fitSims(df, pars, 1, n.subj)
rm(list = ls())
setwd("~/Documents/UVA/2021/pmwg_new/")
source("pmwg/sampling.R")
joint_ll <- function(x, data){
parPreFixs <- gsub("[|].*", "", names(x))
totalSum <- 0
for(mod in unique(parPreFixs)){
currentPars <- x[which(parPreFixs == mod)]
names(currentPars) <- gsub(".*[|]", "", names(currentPars))
modelData <- data[[mod]][[1]]
totalSum <- totalSum + log_likelihood(currentPars, modelData, sample = F)
}
return(totalSum)
}
fitSims <- function(df, pars, var, n.subj){
priors <- list(
theta_mu_mean = rep(0, length(pars)),
theta_mu_var = diag(rep(var, length(pars)))
)
# Create the Particle Metropolis within Gibbs sampler object ------------------
sampler <- pmwgs(
data = df,
pars = pars,
prior = priors,
ll_func = joint_ll
)
# start the sampler ---------------------------------------------------------
sampler <- init(sampler, n_cores = 48) # i don't use any start points here
# Sample! -------------------------------------------------------------------
save(sampler, file = paste0("./samples/LBA_", n.subj, "subs_", n.exp, "tasks_.RData"))
burned <- run_stage(sampler, stage = "burn",iter = 2000, particles = 100, n_cores =48, pstar = .6)
save(burned, file = paste0("./samples/LBA_", n.subj, "subs_", n.exp, "tasks_.RData"))
epsilon <- burned$epsilon[length(burned$epsilon)]
adapted <- run_stage(burned, stage = "adapt", iter = 5000, particles = 100, n_cores = 48, pstar = .6)
epsilon <- adapted$epsilon[length(adapted$epsilon)]
sampled <- run_stage(adapted, stage = "sample", iter = 1000, particles = 100, n_cores = 48, pstar = .6)
save(sampled, file = paste0("./samples/LBA_", n.subj, "subs_", n.exp, "tasks_.RData"))
}
log_likelihood=function(x,data, sample=TRUE) {
x <- exp(x)
bPars <- grep("b", names(x))
bs <- x["A"]+x[bPars][data$condition]
if (sample) { #for sampling
out=rLBA(n=nrow(data),A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
} else { #for calculating density
out=dLBA(rt=data$rt,response=data$resp,A=x["A"],b=bs,t0=x["t0"],mean_v=x[c("v1","v2")],sd_v=c(1,1),distribution="norm",silent=TRUE)
bad=(out<1e-10)|(!is.finite(out))
out[bad]=1e-10
out=sum(log(out))
}
out
}
n.trials <- 100      #number trials per subject per conditions
n.subj <- 15 #number of subjects
n.cond <- 3
n.exp <- 4
allparameters <- numeric()
alldata <- list()
for(i in 1:n.exp){
names=c("subject","rt","resp","condition") #names of columns
data <- data.frame(matrix(NA, ncol = length(names), nrow = (n.trials*n.subj*n.cond))) #empty data frame
names(data) <- names
data$condition <- rep(1:n.cond,times = n.trials) #filling in condition
data$subject <- rep(1:n.subj, each = n.trials*n.cond) #filling in subjects
alldata[[i]] <- data
parameter.names <- c(c("A","v1","v2","t0"), c(paste0("b", 1:3)))
parameters <- c((0.1 + .02*i)*(-1)^i + c(0.4, 1.2, .7, -2.4), seq(0.1, 0.5, length.out = 3))
names(parameters) <- paste0("Mod", i, "|", parameter.names)
allparameters <- c(allparameters, parameters)
}
fillCorMatrix <- function(matrix, name1, name2, value){
matrix[grep(name1, rownames(matrix)), grep(name2, colnames(matrix))] <- value
matrix[grep(name2, rownames(matrix)), grep(name1, colnames(matrix))] <- value
return(matrix)
}
adjustCorMatrix <- function(matrix, adj){
#Was probably a cleverer way to do this
rowNames <- rownames(matrix)
for(i in 1:nrow(matrix)){
rowPreFix <- substr(rowNames[i], 0, 4)
matrix[i,!grepl(rowPreFix, colnames(matrix))] <- .3*matrix[i,!grepl(rowPreFix, colnames(matrix))]
}
return(matrix)
}
exp(allparameters)
n.parameters=length(allparameters)
corMat <- matrix(0, nrow = n.parameters, ncol = n.parameters)
rownames(corMat) <- colnames(corMat) <- names(allparameters)
corMat[grep("A", rownames(corMat)),] <- .3
corMat[,grep("A", colnames(corMat))] <- .3
corMat <- fillCorMatrix(corMat, "v", "b", .25)
corMat <- fillCorMatrix(corMat, "v", "v", .4)
corMat <- fillCorMatrix(corMat, "b", "b", .4)
corMat <- fillCorMatrix(corMat, "t0", "v", -.1)
corMat <- fillCorMatrix(corMat, "t0", "b", -.25)
corMat <- adjustCorMatrix(corMat, .33)
vars = abs(allparameters)/15 #off diagonal correlations are done as absolute/10
###std dev correlation on diagonal - you might think this should be corr = 1, but it's actually the standard deviation
diag(corMat)=sqrt(vars)
corMat <- sdcor2cov(corMat)
subj_random_effects <- t(mvtnorm::rmvnorm(n.subj,mean=allparameters,sigma=corMat))
exp(subj_random_effects)
parPreFixs <- gsub("[|].*", "", rownames(subj_random_effects))
df <- data.frame(subject = 1:n.subj)
for(i in 1:n.exp){
modIdx <- which(parPreFixs == paste0("Mod", i))
task_random_effects <- subj_random_effects[modIdx,]
rownames(task_random_effects) <- gsub(".*[|]", "", rownames(task_random_effects))
data <- alldata[[i]]
for (j in 1:n.subj){
tmp<- log_likelihood(task_random_effects[,j],sample=TRUE,data=data[data$subject==j,])
data$rt[data$subject==j]=tmp$rt
data$resp[data$subject==j]=tmp$response
}
df[paste0("Mod", i)] <- I(list(split(data, f = data$subject)))
}
pars <- rownames(subj_random_effects)
debug(fitSims)
fitSims(df, pars, 1, n.subj)
