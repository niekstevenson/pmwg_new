source("pmwg/sampling.R")
source("pmwg/variants/factor.R")

add_info_factorRegr <- function(sampler, prior = NULL, ...){
  sampler <- add_info_factor(sampler, prior, ...)
  covariates <- list(...)$covariates
  # Add intercept
  covariates <- cbind(rep(1, nrow(covariates)), covariates)
  
  if (is.null(sampler$prior$theta_beta_mean)) {
    sampler$prior$theta_beta_mean = matrix(0, ncol(covariates), sampler$n_factors)
    sampler$prior$theta_beta_sigma = matrix(1, ncol(covariates), sampler$n_factors)
  }
  
  sampler$covariates <- covariates
  sampler$n_covariates <- ncol(covariates)
  return(sampler)
}

sample_store_factorRegr <- function(data, par_names, iters = 1, stage = "init", integrate = T, ...) {
  n_factors <- list(...)$n_factors
  covariates <- list(...)$covariates
  covariates <- cbind(rep(1, nrow(covariates)), covariates)
  n_covariates <- ncol(covariates)
  covariate_names <- colnames(covariates)
  samples <- sample_store_factor(data, par_names, iters, stage, integrate, ...)
  samples$theta_beta <- array(NA_real_, dim = c(n_covariates, n_factors, iters), dimnames = list(covariate_names, NULL, NULL))
  samples$beta_untransf <- array(NA_real_, dim = c(n_covariates, n_factors, iters), dimnames = list(covariate_names, NULL, NULL))
  return(samples)
}


get_startpoints_factorRegr<- function(pmwgs, start_mu, start_var){
  startpoints_fa <- get_startpoints_factor(pmwgs, start_mu, start_var)
  start_beta <- matrix(rnorm(pmwgs$n_covariates*pmwgs$n_factors, 0, 1), pmwgs$n_covariates, pmwgs$n_factors)
  return(list(tmu = startpoints_fa$tmu, tvar = startpoints_fa$tvar, lambda = startpoints_fa$lambda, lambda_untransf = startpoints_fa$lambda,
              sig_err_inv = startpoints_fa$sig_err_inv, psi_inv = startpoints_fa$psi_inv,
              eta = startpoints_fa$eta, beta = start_beta, beta_untransf = start_beta))
}

fill_samples_factorRegr <- function(samples, group_level, proposals, epsilon, j = 1, n_pars){
  samples$theta_beta[,,j] <- group_level$beta
  samples$beta_untransf[,,j] <- group_level$beta_untransf
  # Again since I sourced variants/factor fill_samples == fill_samples_factors
  samples <- fill_samples_factor(samples, group_level, proposals, epsilon, j, n_pars)
  samples <- fill_samples_base(samples, group_level, proposals, epsilon, j = j, n_pars)
  return(samples)
}

gibbs_step_factorRegr <- function(sampler, alpha){
  # Gibbs step for group means with parameter expanded factor analysis from Ghosh & Dunson 2009
  # mu = theta_mu, var = theta_var
  last <- last_sample_factorRegr(sampler$samples)
  hyper <- attributes(sampler)
  prior <- sampler$prior
  
  #extract previous values (for ease of reading)
  
  alpha <- t(alpha)
  n_subjects <- sampler$n_subjects
  n_pars <- sampler$n_pars
  n_factors <- sampler$n_factors
  n_covariates <- sampler$n_covariates
  covariates <- sampler$covariates
  constraintMat <- hyper$constraintMat
  
  eta <- matrix(last$eta, n_subjects, n_factors)
  psi_inv <- matrix(last$psi_inv, n_factors)
  sig_err_inv <- last$sig_err_inv
  lambda <- matrix(last$lambda, n_pars, n_factors)
  mu <- last$mu
  beta <- matrix(last$beta, n_covariates, n_factors)
  x <- sampler$covariates
  
  #Update mu
  mu_sig <- solve(n_subjects * sig_err_inv + prior$theta_mu_invar)
  mu_mu <- mu_sig %*% (sig_err_inv %*% colSums(alpha - eta %*% t(lambda)) + prior$theta_mu_invar%*% prior$theta_mu_mean)
  mu <- rmvnorm(1, mu_mu, mu_sig)
  colnames(mu) <- colnames(alpha)
  # calculate mean-centered observations
  alphatilde <- sweep(alpha, 2, mu)
  
  #Update eta
  eta_sig <- solve(psi_inv + t(lambda) %*% sig_err_inv %*% lambda)
  eta_mu <- eta_sig %*% t((x%*%beta)%*%psi_inv + t(t(lambda) %*% sig_err_inv %*% t(alphatilde)))
  eta[,] <- t(apply(eta_mu, 2, FUN = function(x){rmvnorm(1, x, eta_sig)}))
  
  #Update sig_err
  sig_err_inv <- diag(rgamma(n_pars,shape=(hyper$nu+n_subjects)/2, rate=(hyper$nu*hyper$s2+ colSums((alphatilde - eta %*% t(lambda))^2))/2))
  
  #Update lambda
  for (j in 1:n_pars) {
    constraint <- constraintMat[j,] #T if item is not constraint (bit confusing tbh)
    if(any(constraint)){ #Don't do this if there are no free entries in lambda
      etaS <- eta[,constraint]
      lambda_sig <- solve(sig_err_inv[j,j] * t(etaS) %*% etaS + prior$theta_lambda_invar * diag(1,sum(constraint)))
      lambda_mu <- (lambda_sig * sig_err_inv[j,j]) %*% (t(etaS) %*% alphatilde[,j])
      lambda[j,constraint] <- rmvnorm(1,lambda_mu,lambda_sig)
    }
  }
  
  #Update psi_inv
  psi_inv[,] <- diag(rgamma(n_factors ,shape=(hyper$al+n_subjects)/2,rate=hyper$bl+colSums((eta - x%*%beta)^2)/2), n_factors)
  
  #Update beta
  for (p in 1:n_covariates){
    etatilde <- eta - matrix(x[,-p, drop = F]%*%beta[-p,], nrow = n_subjects)
    betaj_sig <- 1/(prior$theta_beta_sigma[p,]+(sum(x[,p]^2)));
    betaj_mu <- betaj_sig * (prior$theta_beta_sigma[p,]*prior$theta_beta_mean[p,]+colSums(etatilde*x[,p]))
    beta[p,] <- rmvnorm(1, betaj_mu, diag(betaj_sig, n_factors));
  }
  
  lambda_orig <- lambda
  #If the diagonals of lambda aren't constrained to be 1, we should fix the signs
  if(hyper$signFix){
    for(l in 1:n_factors){
      mult <- ifelse(lambda[l, l] < 0, -1, 1) #definitely a more clever function for this 
      lambda_orig[,l] <- mult * lambda[, l]
    }
  }
  
  var <- lambda_orig %*% solve(psi_inv) %*% t(lambda_orig) + diag(1/diag((sig_err_inv)))
  lamdba_orig <- lambda_orig %*% matrix(diag(sqrt(1/diag(psi_inv)), n_factors), nrow = n_factors)
  beta_orig <- beta %*% matrix(diag(sqrt(1/diag(psi_inv)), n_factors), nrow = n_factors)
  return(list(tmu = mu + t(lambda%*%beta[1,]), tvar = var, lambda = lambda_orig, eta = eta, 
              lambda_untransf = lambda, beta_untransf = beta, sig_err_inv = sig_err_inv, 
              psi_inv = psi_inv, beta = beta_orig, alpha = t(alpha)))
}

last_sample_factorRegr <- function(store) {
  list(
    mu = store$theta_mu[, store$idx],
    eta = store$theta_eta[,,store$idx],
    lambda = store$lambda_untransf[,,store$idx],
    beta = store$beta_untransf[,,store$idx],
    psi_inv = store$theta_psi_inv[,,store$idx],
    sig_err_inv = store$theta_sig_err_inv[,,store$idx]
  )
}

get_conditionals_factorRegr <- function(s, samples, n_pars){
  iteration <- samples$iteration
  sig_err <- log(apply(samples$theta_sig_err_inv,3,diag))
  psi <- log(apply(samples$theta_psi_inv,3,diag))
  eta <- matrix(samples$theta_eta[s,,], nrow = samples$n_factors)
  beta <-  apply(samples$beta_untransf, 3, as.numeric)
  lambda <- apply(samples$lambda_untransf, 3, unwind_lambda, samples$constraintMat, samples$n_factors)
  theta_mu <- samples$theta_mu 
  all_samples <- rbind(samples$alpha[, s,],theta_mu, beta, eta, sig_err, psi, lambda)
  mu_tilde <- rowMeans(all_samples)
  var_tilde <- cov(t(all_samples))
  condmvn <- condMVN(mean = mu_tilde, sigma = var_tilde,
                     dependent.ind = 1:n_pars, given.ind = (n_pars + 1):length(mu_tilde),
                     X.given = c(theta_mu[,iteration],
                                 samples$theta_eta[s,,iteration],
                                 as.numeric(samples$beta_untransf[,,iteration]),
                                 log(diag(samples$theta_sig_err_inv[,, iteration])),
                                 log(apply(samples$theta_psi_inv[,,iteration, drop = F], 3, diag)),
                                 unwind_lambda(samples$lambda_untransf[,, iteration], samples$constraintMat, samples$n_factors)))
  return(list(eff_mu = condmvn$condMean, eff_var = condmvn$condVar))
}

unwind_lambda <- function(lambda, constraintMat, n_factors, reverse = F){
  if(reverse){
    out <- matrix(0, n_randeffect, n_factors)
    out[constraintMat] <- lambda
  } else{
    out <- as.numeric(lambda[constraintMat])
  }
  return(out)
}

filtered_samples_factorRegr <- function(sampler, filter){
  out <- list(
    theta_mu = sampler$samples$theta_mu[, filter],
    lambda_untransf = sampler$samples$lambda_untransf[, , filter, drop = F],
    theta_psi_inv = sampler$samples$theta_psi_inv[, , filter, drop = F],
    theta_sig_err_inv = sampler$samples$theta_sig_err_inv[, , filter],
    theta_eta = sampler$samples$theta_eta[, , filter, drop = F],
    beta_untransf = sampler$samples$beta_untransf[, , filter, drop = F],
    theta_var = sampler$samples$theta_var[,,filter],
    alpha = sampler$samples$alpha[, , filter],
    constraintMat = attributes(sampler)$constraintMat,
    n_factors = sampler$n_factors,
    n_covariates = sampler$n_covariates,
    iteration = length(filter)
  )
}

variant_funs <- list(
  sample_store = sample_store_factorRegr,
  add_info = add_info_factorRegr,
  get_startpoints = get_startpoints_factorRegr,
  fill_samples = fill_samples_factorRegr,
  gibbs_step = gibbs_step_factorRegr,
  get_group_level = get_group_level_standard,
  get_conditionals = get_conditionals_factorRegr,
  filtered_samples = filtered_samples_factorRegr
)

